[
  {
    "category": "functional",
    "description": "001 - Airflow Lichess full pipeline for rapid games",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect fork and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "002 - Airflow Chess.com full pipeline for blitz games",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect pin and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "003 - Lichess pipeline handles incremental sync with since param",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect skewer and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "004 - Chess.com pipeline handles incremental sync with cursor",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect discovered attack and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "005 - Pipeline resumes after network interruption mid-fetch",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect mate in 1 and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "006 - Pipeline resumes after Stockfish crash during analysis",
    "steps": [
      "Step 1: Trigger Airflow DAG analyze_tactics for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect mate in 2 and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "007 - Raw PGN persisted verbatim and versioned",
    "steps": [
      "Step 1: Trigger Airflow DAG extract_positions for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect hanging piece and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "008 - Position extraction captures side to move with ply and clocks",
    "steps": [
      "Step 1: Trigger Airflow DAG extract_positions for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect fork and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "009 - Stockfish deterministic settings applied for all analyses",
    "steps": [
      "Step 1: Trigger Airflow DAG analyze_tactics for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect pin and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "010 - Tactics classification found/missed/failed mapped per move",
    "steps": [
      "Step 1: Trigger Airflow DAG analyze_tactics for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect skewer and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "011 - Metrics refresh produces motif breakdown and trends",
    "steps": [
      "Step 1: Trigger Airflow DAG refresh_metrics for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect discovered check and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "012 - SSE stream delivers job progress to UI",
    "steps": [
      "Step 1: Trigger Airflow DAG jobs_stream for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect mate in 1 and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "013 - Practice queue builds from missed tactics only",
    "steps": [
      "Step 1: Trigger Airflow DAG refresh_metrics for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect fork and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "014 - Practice attempt grading updates training_attempts table",
    "steps": [
      "Step 1: Trigger Airflow DAG practice for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect pin and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "015 - DuckDB schema migration preserves data across versions",
    "steps": [
      "Step 1: Trigger Airflow DAG migrations for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect skewer and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "016 - API authentication with local token applied to all routes",
    "steps": [
      "Step 1: Trigger Airflow DAG api for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect discovered attack and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "017 - React dashboard shows motif breakdown and filters",
    "steps": [
      "Step 1: Trigger Airflow DAG ui for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect mate in 2 and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "018 - React training board enforces legal moves and feedback",
    "steps": [
      "Step 1: Trigger Airflow DAG ui for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect fork and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "019 - Airflow backfill replays historical games without duplicates",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect pin and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "020 - Airflow retries with exponential backoff on API 429",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect skewer and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "021 - Chess.com pagination handles >200 games per pull",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect discovered check and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "022 - Lichess OAuth token refresh keeps sync alive",
    "steps": [
      "Step 1: Trigger Airflow DAG daily_game_sync for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect mate in 1 and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "023 - Stockfish engine checksum pinned for reproducibility",
    "steps": [
      "Step 1: Trigger Airflow DAG analyze_tactics for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect hanging piece and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "024 - Rust position extractor handles promotion and en passant",
    "steps": [
      "Step 1: Trigger Airflow DAG extract_positions for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect fork and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "025 - Rust extractor handles castling both sides",
    "steps": [
      "Step 1: Trigger Airflow DAG extract_positions for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect pin and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "026 - Rolling averages computed for 7 and 30 games",
    "steps": [
      "Step 1: Trigger Airflow DAG refresh_metrics for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect skewer and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "025a - Airflow workflow collects game data from Chess.com using the user from the .env file",
    "steps": [
      "Import `load_dotenv` from `dotenv`",
      "Import `os` module",
      "Load environment variables from the .env file with `load_dotenv()`",
      "Read the username from the .env file using `os.getenv('CHESSCOM_USERNAME')`",
      "Use the retrieved username to fetch game data from Chess.com API",
      "Verify that the fetched data corresponds to the specified user in the UI",
      "Write unit tests to mock environment variable loading and API calls",
      "Run end-to-end tests to ensure the workflow functions correctly with the .env configuration",
      "Write unit tests to ensure the username is included as either the white or black player in the fetched games"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "025b - Airflow workflow collects game data from Lichess using the user from the .env file",
    "steps": [
      "Import `load_dotenv` from `dotenv`",
      "Import `os` module",
      "Load environment variables from the .env file with `load_dotenv()`",
      "Read the username from the .env file using `os.getenv('LICHESS_USERNAME')`",
      "Use the retrieved username to fetch game data from Lichess API",
      "Verify that the fetched data corresponds to the specified user in the UI",
      "Write unit tests to mock environment variable loading and API calls",
      "Run end-to-end tests to ensure the workflow functions correctly with the .env configuration",
      "Write unit tests to ensure the username is included as either the white or black player in the fetched games"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "027 - Time-trouble correlation calculated per time control",
    "steps": [
      "Step 1: Trigger Airflow DAG refresh_metrics for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect discovered attack and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "028 - API /api/practice/next returns only unseen tactics",
    "steps": [
      "Step 1: Trigger Airflow DAG api for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect mate in 2 and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "029 - API /api/practice/attempt records success and latency",
    "steps": [
      "Step 1: Trigger Airflow DAG api for Chess.com data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Chess.com games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect fork and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "030 - UI practice session tracks streaks and progress bars",
    "steps": [
      "Step 1: Trigger Airflow DAG ui for Lichess data",
      "Step 2: Confirm scheduler queues the run with correct execution date",
      "Step 3: Fetch Lichess games incrementally with authentication if required",
      "Step 4: Persist raw PGN verbatim into DuckDB raw_pgns table with metadata",
      "Step 5: Run Rust position extractor to emit FENs only when user is to move",
      "Step 6: Record move number, ply, user move, and remaining clocks in positions table",
      "Step 7: Execute Stockfish with pinned settings to detect pin and other motifs",
      "Step 8: Classify tactic outcomes (found/missed/failed_attempt/unclear) per move",
      "Step 9: Update DuckDB tactics and tactic_outcomes tables with severity and eval deltas",
      "Step 10: Refresh aggregated metrics for dashboards and practice queues",
      "Step 11: Load React dashboard and verify new data and explanations appear without stale cache"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess bullet games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Lichess bullet profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess bullet games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Lichess bullet profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess blitz games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Lichess blitz profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess blitz games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Lichess blitz profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess rapid games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Lichess rapid profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess rapid games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Lichess rapid profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess classical games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Lichess classical profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess classical games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Lichess classical profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess correspondence games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Lichess correspondence profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Lichess correspondence games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Lichess correspondence profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com bullet games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Chess.com bullet profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com bullet games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Chess.com bullet profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com blitz games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Chess.com blitz profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com blitz games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Chess.com blitz profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com rapid games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Chess.com rapid profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com rapid games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Chess.com rapid profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com classical games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Chess.com classical profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com classical games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Chess.com classical profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com correspondence games via incremental sync",
    "steps": [
      "Step 1: Configure incremental run for Chess.com correspondence profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Ingestion Chess.com correspondence games via full backfill sync",
    "steps": [
      "Step 1: Configure full backfill run for Chess.com correspondence profile",
      "Step 2: Execute DAG pull and honor API rate limits",
      "Step 3: Store new games only without duplicating existing IDs",
      "Step 4: Persist raw PGNs with site metadata",
      "Step 5: Mark run status success in Airflow and metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Lichess bullet",
    "steps": [
      "Step 1: Replay Lichess bullet PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Lichess blitz",
    "steps": [
      "Step 1: Replay Lichess blitz PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Lichess rapid",
    "steps": [
      "Step 1: Replay Lichess rapid PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Lichess classical",
    "steps": [
      "Step 1: Replay Lichess classical PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Lichess correspondence",
    "steps": [
      "Step 1: Replay Lichess correspondence PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Lichess bullet",
    "steps": [
      "Step 1: Replay Lichess bullet PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Lichess blitz",
    "steps": [
      "Step 1: Replay Lichess blitz PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Lichess rapid",
    "steps": [
      "Step 1: Replay Lichess rapid PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Lichess classical",
    "steps": [
      "Step 1: Replay Lichess classical PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Lichess correspondence",
    "steps": [
      "Step 1: Replay Lichess correspondence PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Chess.com bullet",
    "steps": [
      "Step 1: Replay Chess.com bullet PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Chess.com blitz",
    "steps": [
      "Step 1: Replay Chess.com blitz PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Chess.com rapid",
    "steps": [
      "Step 1: Replay Chess.com rapid PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Chess.com classical",
    "steps": [
      "Step 1: Replay Chess.com classical PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records white to move for Chess.com correspondence",
    "steps": [
      "Step 1: Replay Chess.com correspondence PGN move-by-move",
      "Step 2: Capture FEN only when white is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Chess.com bullet",
    "steps": [
      "Step 1: Replay Chess.com bullet PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Chess.com blitz",
    "steps": [
      "Step 1: Replay Chess.com blitz PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Chess.com rapid",
    "steps": [
      "Step 1: Replay Chess.com rapid PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Chess.com classical",
    "steps": [
      "Step 1: Replay Chess.com classical PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Position extraction records black to move for Chess.com correspondence",
    "steps": [
      "Step 1: Replay Chess.com correspondence PGN move-by-move",
      "Step 2: Capture FEN only when black is to move",
      "Step 3: Record ply, move number, and clocks",
      "Step 4: Save user move and legality flag"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with low severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with low severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with low severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with low severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with low severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with high severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with high severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with high severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with high severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 1 with high severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure mate in 1 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with low severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with low severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with low severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with low severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with low severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with high severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with high severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with high severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with high severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects mate in 2 with high severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure mate in 2 is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with low severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure fork is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with low severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure fork is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with low severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure fork is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with low severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure fork is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with low severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure fork is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with high severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure fork is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with high severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure fork is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tactix correctly classifies positions in tests/fixtures/matein1.pgn as mate in 1",
    "steps": [
      "Step 1: Load positions from tests/fixtures/matein1.pgn",
      "Step 2: Run tacics detection engine on each position",
      "Step 3: Verify that each position is classified as mate in 1",
      "Step 4: Verify that each position is only classified as mate in 1",
      "Step 5: Test each position in the fixture every time `make check` is run"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tactix correctly classifies positions in tests/fixtures/matein2.pgn as mate in 2",
    "steps": [
      "Step 1: Load positions from tests/fixtures/matein2.pgn",
      "Step 2: Run tacics detection engine on each position",
      "Step 3: Verify that each position is classified as mate in 2",
      "Step 4: Verify that each position is only classified as mate in 2",
      "Step 5: Test each position in the fixture every time `make check` is run"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tactix correctly classifies positions in tests/fixtures/hangingpiece.pgn as hanging piece",
    "steps": [
      "Step 1: Load positions from tests/fixtures/hangingpiece.pgn",
      "Step 2: Run tacics detection engine on each position",
      "Step 3: Verify that each position is classified as hanging piece",
      "Step 4: Verify that each position is only classified as hanging piece",
      "Step 5: Test each position in the fixture every time `make check` is run"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tactix correctly classifies positions in tests/fixtures/fork.pgn as fork",
    "steps": [
      "Step 1: Load positions from tests/fixtures/fork.pgn",
      "Step 2: Run tacics detection engine on each position",
      "Step 3: Verify that each position is classified as fork",
      "Step 4: Verify that each position is only classified as fork",
      "Step 5: Test each position in the fixture every time `make check` is run"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tactix correctly classifies positions in tests/fixtures/pin.pgn as pin",
    "steps": [
      "Step 1: Load positions from tests/fixtures/pin.pgn",
      "Step 2: Run tacics detection engine on each position",
      "Step 3: Verify that each position is classified as pin",
      "Step 4: Verify that each position is only classified as pin",
      "Step 5: Test each position in the fixture every time `make check` is run"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tactix correctly classifies positions in tests/fixtures/skewer.pgn as skewer",
    "steps": [
      "Step 1: Load positions from tests/fixtures/skewer.pgn",
      "Step 2: Run tacics detection engine on each position",
      "Step 3: Verify that each position is classified as skewer",
      "Step 4: Verify that each position is only classified as skewer",
      "Step 5: Test each position in the fixture every time `make check` is run"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tactix correctly classifies positions in tests/fixtures/discoveredattack.pgn as discovered attack",
    "steps": [
      "Step 1: Load positions from tests/fixtures/discoveredattack.pgn",
      "Step 2: Run tacics detection engine on each position",
      "Step 3: Verify that each position is classified as discovered attack",
      "Step 4: Verify that each position is only classified as discovered attack",
      "Step 5: Test each position in the fixture every time `make check` is run"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Tactix converts collected games into fen positions for tactic analysis",
    "steps": [
      "Step 1: Retrieve collected games from database",
      "Step 2: Parse PGNs to extract move-by-move positions",
      "Step 3: Generate FEN strings for each position",
      "Step 4: Store FEN positions with metadata for tactic detection"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Airflow pipeline hashes and stores raw PGNs from Lichess and Chess.com",
    "steps": [
      "Step 1: Retrieve raw PGNs from data ingestion tasks",
      "Step 2: Compute hash for each game inside each PGN",
      "Step 3: Store hashed PGNs in persistent storage with site metadata",
      "Step 4: Mark run status success in Airflow and log metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Airflow pipeline correctly hashes and stores each game from Lichess and Chess.com separately",
    "steps": [
      "Step 1: Retrieve raw PGNs from data ingestion tasks",
      "Step 2: Compute hash for each game inside each PGN",
      "Step 3: Store hashed PGNs in persistent storage with site metadata",
      "Step 4: Ensure that the number of stored games matches the number of hashes computed",
      "Step 5: Mark run status success in Airflow and log metrics"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Airflow pipeline runs every hour to get new games from Lichess and Chess.com",
    "steps": [
      "Step 1: Schedule DAG to run hourly",
      "Step 2: Execute data ingestion tasks for Lichess and Chess.com",
      "Step 3: Monitor for successful completion and log metrics",
      "Step 4: Handle any errors or retries as needed"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Airflow pipeline runs on trigger from dashboard to get new games from Lichess and Chess.com",
    "steps": [
      "Step 1: Set up DAG to be triggerable from dashboard",
      "Step 2: Execute data ingestion tasks for Lichess and Chess.com upon trigger",
      "Step 3: Monitor for successful completion and log metrics",
      "Step 4: Handle any errors or retries as needed"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Airflow pipeline runs on trigger from dashboard to backfill historical games from Lichess and Chess.com",
    "steps": [
      "Step 1: Set up DAG to be triggerable from dashboard",
      "Step 2: Execute data ingestion tasks for Lichess and Chess.com backfill upon trigger",
      "Step 3: Monitor for successful completion and log metrics",
      "Step 4: Check that all incoming games are dated prior to the trigger time",
      "Step 5: Handle any errors or retries as needed",
      "Step 6: Ensure no duplication of existing game IDs"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Airflow pipeline is monitoring incoming games and triggers tactic analysis for new positions",
    "steps": [
      "Step 1: Continuously monitor database for newly ingested games",
      "Step 2: Extract positions from new games",
      "Step 3: Trigger tactic analysis engine for each new position",
      "Step 4: Log metrics on number of positions analyzed and tactics detected"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Airflow webserver is deployed and operational",
    "steps": [
      "Step 1: Deploy Airflow webserver using Docker Compose (if not already deployed)",
      "Step 2: Access Airflow webserver at http://localhost:8080",
      "Step 3: Verify that the webserver is running and responsive",
      "Step 4: Check that DAGs are listed and can be triggered manually"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Airflow scheduler is deployed and operational",
    "steps": [
      "Step 1: Deploy Airflow scheduler using Docker Compose (if not already deployed)",
      "Step 2: Verify that the scheduler is running and processing DAGs",
      "Step 3: Check logs for any errors or issues",
      "Step 4: Ensure that scheduled DAGs are executing as expected"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Postgres DB is deployed and operational",
    "steps": [
      "Step 1: Deploy Postgres DB using Docker Compose (if not already deployed)",
      "Step 2: Connect to Postgres DB using a client",
      "Step 3: Verify that the DB is running and accessible",
      "Step 4: Check that required tables and schemas are present",
      "Step 5: Check that Airflow can read/write to the DB",
      "Step 6: Check that tactic analysis engine can read/write to the DB",
      "Step 7: Check that data ingestion tasks can read/write to the DB",
      "Step 8: Trigger a sample DAG run and verify DB interactions"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Airflow uses postgres as its metadata database",
    "steps": [
      "Step 1: Deploy Airflow and Postgres using Docker Compose (if not already deployed)",
      "Step 2: Verify Airflow configuration points to Postgres DB",
      "Step 3: Check Airflow logs for successful connection to Postgres",
      "Step 4: Ensure Airflow can read/write metadata to Postgres DB"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Analysis engine uses postgres to efficiently store and retrieve tactic analysis results",
    "steps": [
      "Step 1: Deploy analysis engine and Postgres using Docker Compose (if not already deployed)",
      "Step 2: Verify analysis engine configuration points to Postgres DB",
      "Step 3: Check analysis engine logs for successful connection to Postgres",
      "Step 4: Ensure analysis engine can read/write tactic analysis results to Postgres DB"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Postgres DB efficiently stores raw string data of PGNs ingested from Lichess and Chess.com",
    "steps": [
      "Step 1: Deploy data ingestion tasks and Postgres using Docker Compose (if not already deployed)",
      "Step 2: Verify data ingestion configuration points to Postgres DB",
      "Step 3: Check data ingestion logs for successful connection to Postgres",
      "Step 4: Ensure data ingestion tasks can read/write raw PGN strings to Postgres DB",
      "Step 5: Ensure individual games within PGNs are stored separately with unique IDs",
      "Step 6: Ensure individual games have metadata such as player info, timestamps, and game results",
      "Step 7: Ensure individual games are normalized for consistent formatting before storage",
      "Step 8: Ensure no duplication of existing game IDs",
      "Step 9: Ensure efficient indexing for fast retrieval of games based on various criteria"
    ],
    "passes": true
  },
  {
    "category": "infrastructure",
    "description": "Rust, python, and TS interfaces efficiently with Postgres using appropriate libraries",
    "steps": [
      "Step 1: Verify Rust code uses `tokio-postgres` or `diesel` for DB interactions",
      "Step 2: Verify Python code uses `psycopg2` or `SQLAlchemy` for DB interactions",
      "Step 3: Verify TypeScript code uses `pg` or `TypeORM` for DB interactions",
      "Step 4: Test CRUD operations from each language to ensure proper connectivity and performance"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with high severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure fork is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with high severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure fork is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects fork with high severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure fork is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with low severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure pin is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with low severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure pin is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with low severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure pin is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with low severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure pin is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with low severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure pin is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "pgadmin added to docker compose for easier db management",
    "steps": [
      "Added pgadmin service to docker-compose.yml",
      "Configured pgadmin to connect to the existing Postgres database",
      "Updated documentation to include instructions for accessing pgadmin",
      "Updated documentation to include postgres schema map information"
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Tactics detection logic consolidation into an abstract base class (or similar in Rust if applicable).",
    "steps": [
      "1. There are several variations on the same theme of detecting forks/pins/etc. There are many ways these need to be verified, but keep in mind that they should be using the same underlying logic where possible to avoid discrepancies.",
      "2. It could be useful to have a abstract BaseTacticDetector class that implements common functionality, and then have specific detectors inherit from this base class. This way we can start to consolidate common logic, and make sure that we are consistent across different tactic detectors.",
      "3. Implement the base class and refactor existing tactic detectors to inherit from it.",
      "4. Thoroughly test to ensure that the refactored detectors behave as expected and produce consistent results.",
      "5. Document the new structure and usage of the base class for future reference.",
      "6. Review and optimize the implementation for performance and maintainability.",
      "7. Replace existing tactic detection logic with the new class structure in all relevant parts of the codebase. This includes updating any tests to ensure they are compatible with the new structure.",
      "8. Keep existing tactic detection tests to verify that the refactored code maintains the same functionality and accuracy as before.",
      "9. Ensure previous code is completely removed and no longer in use.",
      "10. Design tests to ensure that the old code is not inadvertently called or used anywhere in the codebase."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with high severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure pin is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with high severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure pin is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with high severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure pin is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with high severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure pin is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects pin with high severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure pin is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with low severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with low severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with low severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with low severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with low severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with high severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with high severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with high severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with high severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects skewer with high severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure skewer is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Add BaseCard component that all individual card components use",
    "steps": [
      "1. Review common functionality and styling across card components",
      "2. Create BaseCard component with shared logic",
      "3. Refactor individual card components to wrap around BaseCard",
      "4. Test to ensure no regressions in UI or functionality",
      "5. Update documentation to reflect new component structure",
      "6. New functionality: Give cards a collapsed state for compact display: when the user clicks on a card (within the top part of the card), it toggles between expanded and collapsed views",
      "7. All cards default to collapsed state on initial render",
      "8. All cards must have a 'header' prop that is always visible, even in collapsed state",
      "9. When expanded, cards show full content below the header",
      "10. Add smooth transition animation when toggling between states",
      "11. Ensure accessibility compliance for interactive elements",
      "12. Write unit tests to cover the new collapsed/expanded functionality",
      "13. Update existing tests to account for the new card behavior",
      "14. Document the new 'collapsed' feature in the component's README"
    ],
    "passes": true
  },
  {
    "category": "ui/ux",
    "description": "Any card wrapping a base card should be re-orderable by dragging and dropping when in a collapsed state",
    "steps": [
      "Step 1: Integrate drag-and-drop library (e.g., react-beautiful-dnd PLEASE review other options first) to enable reordering functionality",
      "Step 2: Make card components draggable when collapsed",
      "Step 3: Ensure smooth drag-and-drop experience with visual cues, such as a horizontal line indicating drop position",
      "Step 4: Update the state to reflect new order after a drag-and-drop action",
      "Step 5: Test drag-and-drop functionality across different browsers and devices",
      "Step 6: Ensure accessibility compliance for drag-and-drop interactions",
      "Step 7: Write unit and integration tests to cover drag-and-drop functionality",
      "Step 8: Update documentation to include instructions on using the drag-and-drop feature",
      "Step 9: Save the new order in local storage or backend to persist user preferences"
    ],
    "passes": true
  },
  {
    "category": "ui/ux",
    "description": "Allow users to customize the order of tactic motifs in the dashboard",
    "steps": [
      "Step 1: Ensure the dashboard UI is set up to display tactic motifs",
      "Step 2: Implement tactical motif cards by wrapping a BaseCard component",
      "Step 3: Ensure that the drag-and-drop ordering of motif cards works now, by virtue of wrapping BaseCard",
      "Step 4: If not, implement drag-and-drop functionality using a library like react-beautiful-dnd to the BaseCard component, not to the motif cards directly",
      "Step 5: Add state management to track the order of motif cards (e.g., using React's useState or a state management library)",
      "Step 6: Implement event handlers to update the order state when a user drags and drops a motif card",
      "Step 7: Add visual indicators (like a shadow or highlight) to show which card is being dragged",
      "Step 8: Test the drag-and-drop functionality across different browsers and devices to ensure compatibility",
      "Step 9: Save the new order in local storage or backend to persist user preferences"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with low severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with low severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with low severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with low severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with low severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with high severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with high severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with high severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with high severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered attack with high severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure discovered attack is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with low severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with low severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with low severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with low severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with low severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with high severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with high severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with high severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with high severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects discovered check with high severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure discovered check is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with low severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with low severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "When user opens the dashboard, the default view combines all online chess sites (that are configured) and all time controls from those sites into a single unified view.",
    "steps": [
      "Open the dashboard.",
      "Verify that the default view shows games from chess.com",
      "Verify that the default view shows games from lichess.org",
      "Verify that the default view shows bullet games, blitz games, and rapid games from both sites."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "User can filter the dashboard view by chess site and time control using the filter controls.",
    "steps": [
      "Open the dashboard.",
      "Use the filter controls to select only chess.com games.",
      "Verify that only chess.com games are shown in the dashboard.",
      "Use the filter controls to select only blitz games.",
      "Verify that only blitz games are shown in the dashboard."
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "All tables in the dashboard wrap a common BaseTable component that handles table functionality like sorting, pagination, and styling.",
    "steps": [
      "Review the usage of table components in the dashboard.",
      "Research OSS table components that could be used as a BaseTable.",
      "Open the dashboard code and either wrap an OSS table component or create a custom BaseTable component.",
      "Verify that all table components extend from BaseTable.",
      "Verify that sorting, pagination, and styling are handled by BaseTable.",
      "Verify that higher-level table components do not duplicate table functionality or reproduce styling.",
      "Verify that higher-level table components only handle data fetching and specific column definitions.",
      "Ensure data fetching logic is separated from table rendering logic.",
      "Ensure the only props passed to higher-level table components are data and column definitions."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "User can click on a game in the dashboard to open a detailed game view with move list and analysis.",
    "steps": [
      "Open the dashboard.",
      "Click on a game entry in the table.",
      "Verify that a detailed game view opens.",
      "Verify that the detailed game view shows the full move list.",
      "Verify that the detailed game view includes analysis features like engine evaluation and blunder checks."
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Recent games from any site and time control are shown in a BaseCard component on the dashboard.",
    "steps": [
      "Open the dashboard.",
      "Verify that recent games from chess.com are shown in a BaseCard component titled 'Recent Games' or similar.",
      "Verify that recent games from lichess.org are shown in the same BaseCard component.",
      "Verify that the BaseCard component displays key game details like opponent, result, and date.",
      "Verify that the table wraps a common BaseTable component for consistent styling and functionality."
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "All top-level cards/containers in the dashboard wrap the BaseCard component for consistent styling and layout.",
    "steps": [
      "Review the usage of card/container components in the dashboard.",
      "Open the dashboard code and view each top-level card/container component.",
      "Verify that each top-level card/container component extends from BaseCard.",
      "Verify that styling and layout are handled by BaseCard.",
      "Verify that higher-level card/container components do not duplicate styling or layout logic.",
      "Verify that higher-level card/container components only handle content and specific functionality.",
      "Verify that higher-level card/container components are each defined separately in their own files and no containers are defined in App.tsx or other high-level files."
    ],
    "passes": true
  },
  {
    "category": "data load",
    "description": "Historical game data for the user is pre-fetched, cached, and ready to be used immediately upon dashboard load.",
    "steps": [
      "Run the airflow pipeline to collect lichess game data for the user.",
      "Run the airflow pipeline to collect chess.com game data for the user.",
      "Ensure both sites' game data is stored in the database.",
      "Open the dashboard.",
      "Verify that historical game data from both sites is immediately available in the dashboard without additional loading time (except minor database network latency)."
    ],
    "passes": true
  },
  {
    "category": "ui/ux",
    "description": "Clicking on a game in a dashboard table opens a modal with detailed game information and analysis.",
    "steps": [
      "Open the dashboard.",
      "Click on a game entry in any of the tables.",
      "Verify that a modal window opens displaying detailed game information.",
      "Verify that the modal includes the full move list, player information, and game metadata.",
      "Verify that the modal allows the user to step through the moves of the game with navigation control buttons.",
      "Verify that the modal allows the user to step through the moves of the game using keyboard arrow keys (left/right -> previous/next move, up/down -> start/end of the line or game)."
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Refactor the python code `chesscom_client.py` to improve code organization, readability, and maintainability.",
    "steps": [
      "Review the existing `chesscom_client.py` code.",
      "Verify the file is 100% covered by unit tests before making changes.",
      "Add a ChesscomClient class (if it doesn't already exist) to encapsulate Chess.com API interactions and state.",
      "Add pydantic models for request and response data structures to improve type safety and validation.",
      "Add a ChesscomClientContext data class to encapsulate configuration and state related to the Chess.com client.",
      "Refactor to pass the ChesscomClientContext object to functions and methods that require configuration or state, instead of using global variables or multiple parameters.",
      "Modularize the code by breaking down large functions and methods into smaller, single-responsibility functions and methods.",
      "Prefer methods on the ChesscomClient class for operations that involve Chess.com API interactions.",
      "Improve error handling by adding specific exceptions and logging.",
      "Simplify complex logic and remove any redundant code.",
      "Add docstrings to every function/class to explain their purpose.",
      "Ensure docstrings on public methods follow the Google style guide and explain their purpose, parameters, return values, exceptions raised, and any side effects.",
      "Ensure also that public methods have examples in their docstrings where applicable.",
      "If any function exceeds 10 lines, it MUST be broken down into smaller functions and methods.",
      "Private functions and methods should be expressively named with a leading underscore.",
      "After refactoring, run all unit tests to ensure no functionality is broken.",
      "Each new function added must have specific unit tests to verify its SINGLE RESPONSIBILITY."
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Refactor the python code `lichess_client.py` to improve code organization, readability, and maintainability.",
    "steps": [
      "Review the existing `lichess_client.py` code.",
      "Verify the file is 100% covered by unit tests before making changes.",
      "Add a LichessClient class (if it doesn't already exist) to encapsulate Lichess API interactions and state.",
      "Add pydantic models for request and response data structures to improve type safety and validation.",
      "Add a LichessClientContext data class to encapsulate configuration and state related to the Lichess client.",
      "Refactor to pass the LichessClientContext object to functions and methods that require configuration or state, instead of using global variables or multiple parameters.",
      "Modularize the code by breaking down large functions and methods into smaller, single-responsibility functions and methods.",
      "Prefer methods on the LichessClient class for operations that involve Lichess API interactions.",
      "Improve error handling by adding specific exceptions and logging.",
      "Simplify complex logic and remove any redundant code.",
      "Add docstrings to every function/class to explain their purpose.",
      "Ensure docstrings on public methods follow the Google style guide and explain their purpose, parameters, return values, exceptions raised, and any side effects.",
      "Ensure also that public methods have examples in their docstrings where applicable.",
      "If any function exceeds 10 lines, it MUST be broken down into smaller functions and methods.",
      "Private functions and methods should be expressively named with a leading underscore.",
      "After refactoring, run all unit tests to ensure no functionality is broken.",
      "Each new function added must have specific unit tests to verify its SINGLE RESPONSIBILITY."
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Refactor the python code `lichess_client.py` and `chesscom_client.py` to share a new common base client for shared functionality.",
    "steps": [
      "Review the existing code in both `lichess_client.py` and `chesscom_client.py`.",
      "Verify the file is 100% covered by unit tests before making changes.",
      "Consider combining shared pydantic models for request and response data structures to improve type safety and validation if doing so does not reduce clarity.",
      "Create a BaseChessClient class to encapsulate shared functionality between the LichessClient and ChesscomClient.",
      "Refactor both clients to inherit from BaseChessClient and utilize shared functionality.",
      "Ensure that each client retains its specific functionality and API interactions.",
      "After refactoring, run all unit tests to ensure no functionality is broken.",
      "Each new function added must have specific unit tests to verify its SINGLE RESPONSIBILITY."
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Use the newly-created BaseChessClient in the dashboard code to interact with both chess.com and lichess.org APIs.",
    "steps": [
      "Open the dashboard code and locate all instances where `LichessClient` and `ChesscomClient` are used, or their proxy functions are called.",
      "Refactor the code to use `BaseChessClient` instead of specific references to the specific website clients.",
      "Ensure that the dashboard code can still access all necessary functionality from both clients via the base class.",
      "Run all unit tests to ensure no functionality is broken after the refactor.",
      "Ensure that downstream code using the clients is updated to accept a client object as an injectable dependency, rather than instantiating specific clients directly."
    ],
    "passes": true
  },
  {
    "category": "refactor",
    "description": "Refactor `duckdb_store.py` and `postgres_store.py` to share a new common base store for shared functionality.",
    "passes": true,
    "steps": [
      "1. Review the refactoring steps from the previous tasks on `lichess_client.py` and `chesscom_client.py` to create a BaseChessClient.",
      "2. Review the existing code in both `duckdb_store.py` and `postgres_store.py`.",
      "3. Verify the files are 100% covered by unit tests before making changes.",
      "4. Create a BaseDbStore class to encapsulate shared functionality between DuckDB and Postgres stores.",
      "5. Refactor both store implementations to inherit from BaseDbStore and utilize shared functionality.",
      "6. Ensure that each store retains its specific functionality and database interactions.",
      "7. After refactoring, run all unit tests to ensure no functionality is broken.",
      "8. Each new function added must have specific unit tests to verify its SINGLE RESPONSIBILITY."
    ]
  },
  {
    "category": "refactor",
    "description": "Use the newly-created BaseDbStore in the dashboard code to interact with both DuckDB and Postgres databases.",
    "steps": [
      "Open the dashboard code and locate all instances where `DuckDbStore` and `PostgresStore` are used, or their proxy functions are called.",
      "Refactor the code to use `BaseDbStore` instead of specific references to the specific database stores.",
      "Ensure that the dashboard code can still access all necessary functionality from both stores via the base class.",
      "Run all unit tests to ensure no functionality is broken after the refactor.",
      "Ensure that downstream code using the stores is updated to accept a store object as an injectable dependency, rather than instantiating specific stores directly."
    ],
    "passes": true
  },
  {
    "category": "testing",
    "description": "Stress-test the newly-created BaseChessClient and BaseDbStore by implementing a mock client and mock store.",
    "passes": true,
    "steps": [
      "Create a MockChessClient that inherits from BaseChessClient and simulates API interactions without making real network calls.",
      "Create a MockDbStore that inherits from BaseDbStore and simulates database interactions without connecting to a real database.",
      "Ensure that both mocks can be used anywhere in the dashboard without specifically making cases for them.",
      "Ensure all clients and stores take a client/store object as a parameter to their constructors so that the mocks can be injected.",
      "Run the unit tests to ensure that the mock implementations work correctly and that the dashboard code interacts properly with the base classes.",
      "Verify that no real network calls or database connections are made during testing."
    ]
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with low severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with low severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with low severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as low",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with high severity in bullet",
    "steps": [
      "Step 1: Run engine with pinned depth on bullet sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with high severity in blitz",
    "steps": [
      "Step 1: Run engine with pinned depth on blitz sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with high severity in rapid",
    "steps": [
      "Step 1: Run engine with pinned depth on rapid sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with high severity in classical",
    "steps": [
      "Step 1: Run engine with pinned depth on classical sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Stockfish detects hanging piece with high severity in correspondence",
    "steps": [
      "Step 1: Run engine with pinned depth on correspondence sample",
      "Step 2: Ensure hanging piece is identified with eval delta tagged as high",
      "Step 3: Persist best line and explanation",
      "Step 4: Link tactic to position row"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome found recorded for mate in 1",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as found and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome found recorded for mate in 2",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as found and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome found recorded for fork",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as found and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome found recorded for pin",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as found and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome found recorded for skewer",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as found and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome found recorded for discovered attack",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as found and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome found recorded for discovered check",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as found and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome found recorded for hanging piece",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as found and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome missed recorded for mate in 1",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as missed and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome missed recorded for mate in 2",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as missed and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome missed recorded for fork",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as missed and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome missed recorded for pin",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as missed and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome missed recorded for skewer",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as missed and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome missed recorded for discovered attack",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as missed and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome missed recorded for discovered check",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as missed and store"],
    "passes": true
  },
  {
    "category": "bug fix",
    "description": "Ensure the client correctly uses the BaseTable component",
    "steps": [
      "Current error message:",
      "[plugin:vite:import-analysis] Failed to resolve import '@tanstack/react-table' from 'src/_components/BaseTable.tsx'. Does the file exist?",
      "/app/src/_components/BaseTable.tsx:9:7",
      "7  |    getSortedRowModel,",
      "8  |    useReactTable",
      "9  |  } from '@tanstack/react-table';",
      "   |          ^",
      "10 |  import { useMemo, useState } from 'react';",
      "11 |  const DEFAULT_PAGE_SIZES = [5, 10, 20];",
      "    at TransformPluginContext._formatError (file:///app/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:49258:41)",
      "    at TransformPluginContext.error (file:///app/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:49253:16)",
      "    at normalizeUrl (file:///app/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:64307:23)",
      "    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)",
      "    at async file:///app/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:64439:39",
      "    at async Promise.all (index 1)",
      "    at async TransformPluginContext.transform (file:///app/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:64366:7)",
      "    at async PluginContainer.transform (file:///app/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:49099:18)",
      "    at async loadAndTransform (file:///app/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:51978:27)",
      "    at async viteTransformMiddleware (file:///app/node_modules/vite/dist/node/chunks/dep-BK3b2jBa.js:62106:24"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome missed recorded for hanging piece",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as missed and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome failed_attempt recorded for mate in 1",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as failed_attempt and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome failed_attempt recorded for mate in 2",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as failed_attempt and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome failed_attempt recorded for fork",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as failed_attempt and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome failed_attempt recorded for pin",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as failed_attempt and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome failed_attempt recorded for skewer",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as failed_attempt and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome failed_attempt recorded for discovered attack",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as failed_attempt and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome failed_attempt recorded for discovered check",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as failed_attempt and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome failed_attempt recorded for hanging piece",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as failed_attempt and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome unclear recorded for mate in 1",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as unclear and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome unclear recorded for mate in 2",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as unclear and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome unclear recorded for fork",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as unclear and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome unclear recorded for pin",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as unclear and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome unclear recorded for skewer",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as unclear and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome unclear recorded for discovered attack",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as unclear and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome unclear recorded for discovered check",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as unclear and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Outcome unclear recorded for hanging piece",
    "steps": ["Step 1: Compare user move to engine best line", "Step 2: Compute eval swing threshold", "Step 3: Mark outcome as unclear and store"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/stats/motifs returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/stats/motifs with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/stats/trends returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/stats/trends with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/tactics/search returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/tactics/search with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/practice/next returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/practice/next with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/practice/attempt returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/practice/attempt with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/jobs/trigger returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/jobs/trigger with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/jobs/{id} returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/jobs/{id} with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/jobs/{id}/stream returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/jobs/{id}/stream with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/health returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/health with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": true
  },
  {
    "category": "functional",
    "description": "FastAPI endpoint /api/auth/token returns expected schema",
    "steps": ["Step 1: Authenticate with local token", "Step 2: Call /api/auth/token with valid parameters", "Step 3: Validate HTTP 200 and JSON schema"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "SSE stream for metrics pushes incremental updates",
    "steps": ["Step 1: Open SSE connection", "Step 2: Emit metrics update event", "Step 3: Confirm client renders without full reload"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "SSE stream for practice pushes incremental updates",
    "steps": ["Step 1: Open SSE connection", "Step 2: Emit practice update event", "Step 3: Confirm client renders without full reload"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "SSE stream for jobs pushes incremental updates",
    "steps": ["Step 1: Open SSE connection", "Step 2: Emit jobs update event", "Step 3: Confirm client renders without full reload"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports missed tactics only queue",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports mixed review queue",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports motif-focused queue",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports time-control focused queue",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports rating-range focused queue",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports streak tracking",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports hint usage tracking",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports explanation display",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports retry after fail",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Practice mode supports session completion summary",
    "steps": ["Step 1: Request next tactic", "Step 2: Play moves on board", "Step 3: Receive immediate feedback", "Step 4: Update training_attempts metrics"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Airflow DAG daily_game_sync is idempotent and resumable",
    "steps": ["Step 1: Trigger DAG twice with same execution date", "Step 2: Ensure no duplicate rows in DuckDB", "Step 3: Verify run status succeeds and logs show skips"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Airflow DAG extract_positions is idempotent and resumable",
    "steps": ["Step 1: Trigger DAG twice with same execution date", "Step 2: Ensure no duplicate rows in DuckDB", "Step 3: Verify run status succeeds and logs show skips"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Airflow DAG analyze_tactics is idempotent and resumable",
    "steps": ["Step 1: Trigger DAG twice with same execution date", "Step 2: Ensure no duplicate rows in DuckDB", "Step 3: Verify run status succeeds and logs show skips"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Airflow DAG refresh_metrics is idempotent and resumable",
    "steps": ["Step 1: Trigger DAG twice with same execution date", "Step 2: Ensure no duplicate rows in DuckDB", "Step 3: Verify run status succeeds and logs show skips"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces games table primary keys",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces raw_pgns table retains text",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces positions table indexes ply",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces tactics table motif enum",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces tactic_outcomes table outcome enum",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces training_attempts table timestamps",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces parquet export round trip",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces eval delta stored as numeric",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces clocks stored in seconds",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "DuckDB schema enforces severity stored as categorical",
    "steps": ["Step 1: Inspect schema", "Step 2: Insert sample data", "Step 3: Validate constraints hold"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface miss rate by motif",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface miss rate by rating",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface miss rate by time control",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface miss rate by color",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface win rate conditional on tactic",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface rolling 7-game averages",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface rolling 30-game averages",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface trend lines per motif",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface time-trouble correlation",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface practice improvement over time",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface top recurring motifs",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface evaluation swing distribution",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface site comparison",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface session volume over time",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface error budget per run",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface engine version comparison",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface queue length for practice",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface hint usage impact",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface practice success rate",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Metrics surface API latency percentiles",
    "steps": ["Step 1: Run metrics refresh", "Step 2: Query stats endpoint", "Step 3: Validate figures and units"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Local token authentication protects all private endpoints",
    "steps": ["Step 1: Call endpoint without token and expect 401", "Step 2: Call with valid token and expect 200", "Step 3: Confirm token rotation invalidates old token"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Maturin-built Rust extractor loads in Python pipeline",
    "steps": ["Step 1: Build Rust wheel via maturin", "Step 2: Install into virtualenv", "Step 3: Import in Python and extract FEN from sample PGN"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "React router handles dashboard landing route",
    "steps": ["Step 1: Navigate to path", "Step 2: Verify layout renders", "Step 3: Ensure data fetch executes"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "React router handles games list route",
    "steps": ["Step 1: Navigate to path", "Step 2: Verify layout renders", "Step 3: Ensure data fetch executes"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "React router handles tactic detail route",
    "steps": ["Step 1: Navigate to path", "Step 2: Verify layout renders", "Step 3: Ensure data fetch executes"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "React router handles practice session route",
    "steps": ["Step 1: Navigate to path", "Step 2: Verify layout renders", "Step 3: Ensure data fetch executes"],
    "passes": false
  },
  {
    "category": "functional",
    "description": "React router handles job status stream route",
    "steps": ["Step 1: Navigate to path", "Step 2: Verify layout renders", "Step 3: Ensure data fetch executes"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "React router handles settings/token route",
    "steps": ["Step 1: Navigate to path", "Step 2: Verify layout renders", "Step 3: Ensure data fetch executes"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Dashboard typography scales with viewport",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Color palette meets contrast ratios",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Responsive grid for charts",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Practice board fits mobile view",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Buttons have consistent radius and hover",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Charts use accessible colors",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Tables zebra striping",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Loading states skeletons",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Error banners readable",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Dark mode respects palette",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Chessboard piece clarity",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Move list alignment",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Filters alignment and spacing",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Tooltip readability",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: SSE stream indicator visibility",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Call-to-action prominence",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Form field focus ring",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Modal overlay opacity",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Stepper for practice progress",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Empty state illustrations",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Scrollable panels handling",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Card elevation consistency",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Chart legends placement",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Typography hierarchy for headings",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Responsive navbar collapse",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Sticky filter bar",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Chart axes labels legible",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Board coordinates visible",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Button disabled state",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Link underline on focus",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Keyboard navigation support",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: ARIA labels on controls",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Screen reader text for outcomes",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: High-DPI board rendering",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: No layout shift on load",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Animation duration consistency",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Toast notifications position",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Practice feedback color coding",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Tab order logical",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Breadcrumb readability",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Chart tooltip formatting",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Form validation inline hints",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Responsive tables collapse",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Mobile padding for cards",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Contrast for badges",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Icon alt text",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Skip-to-content link",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: SSE reconnect notice",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Chart gridline subtlety",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Board drag-and-drop smoothness",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Button hit area size",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Scrollable modal content",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Legend toggle accessibility",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Focus trap in modals",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Practice timer visibility",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Hover vs touch behavior",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Line height for body text",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Spacing consistency scale",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Practice success banner",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Chart download affordance",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Practice hint icon clarity",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Jobs stream status badge",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Practice streak badge styling",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Responsive breakpoint for filters",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Keyboard shortcuts help panel",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: SSE live dot animation",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Chart color-blind friendly palette",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: Board orientation toggle visibility",
    "steps": ["Step 1: Open dashboard on desktop and mobile", "Step 2: Inspect element appearance", "Step 3: Compare against design guidelines"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #1",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #2",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #3",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #4",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #5",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #6",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #7",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #8",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #9",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #10",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #11",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #12",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #13",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #14",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #15",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #16",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #17",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #18",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #19",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #20",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #21",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #22",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #23",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #24",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #25",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #26",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #27",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #28",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #29",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #30",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #31",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #32",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #33",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #34",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #35",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #36",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #37",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #38",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #39",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #40",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #41",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #42",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #43",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #44",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #45",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #46",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #47",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #48",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #49",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #50",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #51",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #52",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #53",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #54",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #55",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #56",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #57",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #58",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #59",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #60",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #61",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #62",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #63",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #64",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #65",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #66",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #67",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #68",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #69",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #70",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #71",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #72",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "refactor",
    "description": "Regularly do a deep dive of the codebase, identify duplicate functionality or logic, and refactor it into reusable components or functions to improve maintainability.",
    "steps": [
      "Step 1: Conduct a thorough review of the codebase to identify areas with duplicate code or similar logic that can be abstracted into reusable components or functions.",
      "Step 2: Create reusable components or functions for the identified duplicate code, ensuring they are well-documented and tested.",
      "Step 3: Replace the duplicate code in the codebase with calls to the newly created reusable components or functions.",
      "Step 4: Test the refactored code to ensure that functionality remains intact and performance is not negatively impacted."
    ],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #73",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #74",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #75",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #76",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #77",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #78",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #79",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #80",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #81",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #82",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #83",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #84",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  },
  {
    "category": "style",
    "description": "UI style: responsive polish #85",
    "steps": ["Step 1: Load page", "Step 2: Resize viewport", "Step 3: Verify components remain aligned"],
    "passes": false
  }
]
